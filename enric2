We will keep the same architecture and upgrade it properly:

Generic request <T>

Generic response <R>

Use Enum for enrichment type

Keep Strategy + Factory + Template Method

Fully type safe

Still only URL changes per processor

Framework ready

This is production-grade structure.

1Ô∏è‚É£ Enrichment Type Enum

No more string matching.

public enum EnrichmentType {

    PROFILE,
    ONEA_XI,
    ADR
}


Now routing becomes safe. No magic strings.

2Ô∏è‚É£ Generic Request
public class EnrichmentRequest<T> {

    private String dealId;
    private EnrichmentType enrichmentType;
    private T payload;

    public String getDealId() {
        return dealId;
    }

    public void setDealId(String dealId) {
        this.dealId = dealId;
    }

    public EnrichmentType getEnrichmentType() {
        return enrichmentType;
    }

    public void setEnrichmentType(EnrichmentType enrichmentType) {
        this.enrichmentType = enrichmentType;
    }

    public T getPayload() {
        return payload;
    }

    public void setPayload(T payload) {
        this.payload = payload;
    }
}

3Ô∏è‚É£ Generic Response
public class EnrichmentResponse<R> {

    private String dealId;
    private String status;
    private R data;

    public String getDealId() {
        return dealId;
    }

    public void setDealId(String dealId) {
        this.dealId = dealId;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public R getData() {
        return data;
    }

    public void setData(R data) {
        this.data = data;
    }
}

4Ô∏è‚É£ Controller (Fully Generic)
@RestController
@RequestMapping("/api/enrichment")
public class EnrichmentController {

    private final RouterService routerService;

    public EnrichmentController(RouterService routerService) {
        this.routerService = routerService;
    }

    @PostMapping
    public <T, R> ResponseEntity<EnrichmentResponse<R>> route(
            @RequestBody EnrichmentRequest<T> request) {

        EnrichmentResponse<R> response =
                routerService.route(request);

        return ResponseEntity.ok(response);
    }
}

5Ô∏è‚É£ ProductProcessor Strategy (Fully Generic)
public interface ProductProcessor<T, R> {

    EnrichmentType getType();

    EnrichmentResponse<R> process(EnrichmentRequest<T> request);
}

6Ô∏è‚É£ Abstract Processor (Template Method)

Common flow centralized.

public abstract class AbstractProductProcessor<T, R>
        implements ProductProcessor<T, R> {

    protected final RestTemplate restTemplate;

    protected AbstractProductProcessor(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    public EnrichmentResponse<R> process(
            EnrichmentRequest<T> request) {

        validate(request);

        String url = getUrl();

        HttpEntity<T> entity =
                new HttpEntity<>(request.getPayload());

        ResponseEntity<R> response =
                restTemplate.exchange(
                        url,
                        HttpMethod.POST,
                        entity,
                        getResponseType()
                );

        return buildResponse(request.getDealId(),
                response.getBody());
    }

    protected void validate(EnrichmentRequest<T> request) {
        if (request.getDealId() == null) {
            throw new IllegalArgumentException("DealId required");
        }
    }

    protected EnrichmentResponse<R> buildResponse(
            String dealId,
            R body) {

        EnrichmentResponse<R> response =
                new EnrichmentResponse<>();

        response.setDealId(dealId);
        response.setStatus("SUCCESS");
        response.setData(body);

        return response;
    }

    protected abstract String getUrl();

    protected abstract Class<R> getResponseType();
}

7Ô∏è‚É£ Concrete Processor ‚Äì Example 1 (Profile)

Assume:

Request payload = ProfileRequest

Response payload = ProfileResponse

@Component
public class ProfileProcessor
        extends AbstractProductProcessor<
                ProfileRequest,
                ProfileResponse> {

    @Value("${processor.profile.url}")
    private String profileUrl;

    public ProfileProcessor(RestTemplate restTemplate) {
        super(restTemplate);
    }

    @Override
    public EnrichmentType getType() {
        return EnrichmentType.PROFILE;
    }

    @Override
    protected String getUrl() {
        return profileUrl;
    }

    @Override
    protected Class<ProfileResponse> getResponseType() {
        return ProfileResponse.class;
    }
}

8Ô∏è‚É£ Concrete Processor ‚Äì Example 2 (ADR)
@Component
public class AdrProcessor
        extends AbstractProductProcessor<
                AdrRequest,
                AdrResponse> {

    @Value("${processor.adr.url}")
    private String adrUrl;

    public AdrProcessor(RestTemplate restTemplate) {
        super(restTemplate);
    }

    @Override
    public EnrichmentType getType() {
        return EnrichmentType.ADR;
    }

    @Override
    protected String getUrl() {
        return adrUrl;
    }

    @Override
    protected Class<AdrResponse> getResponseType() {
        return AdrResponse.class;
    }
}

9Ô∏è‚É£ Factory (Clean + Enum Based)

No bean name tricks. Pure enum mapping.

@Component
public class ProductProcessorFactory {

    private final Map<EnrichmentType,
            ProductProcessor<?, ?>> processorMap;

    public ProductProcessorFactory(
            List<ProductProcessor<?, ?>> processors) {

        this.processorMap = processors.stream()
                .collect(Collectors.toMap(
                        ProductProcessor::getType,
                        Function.identity()
                ));
    }

    @SuppressWarnings("unchecked")
    public <T, R> ProductProcessor<T, R>
    getProcessor(EnrichmentType type) {

        ProductProcessor<?, ?> processor =
                processorMap.get(type);

        if (processor == null) {
            throw new IllegalArgumentException(
                    "No processor found for " + type);
        }

        return (ProductProcessor<T, R>) processor;
    }
}

üîü Router Service (Generic Safe)
@Service
public class RouterService {

    private final ProductProcessorFactory factory;

    public RouterService(ProductProcessorFactory factory) {
        this.factory = factory;
    }

    public <T, R> EnrichmentResponse<R> route(
            EnrichmentRequest<T> request) {

        ProductProcessor<T, R> processor =
                factory.getProcessor(
                        request.getEnrichmentType());

        return processor.process(request);
    }
}

Real Market Data Example
Example 1 ‚Äì PROFILE

Input:

dealId: D1001
enrichmentType: PROFILE
payload:
   accountNumber: ACC123
   documentName: DOC1


Router selects ProfileProcessor.

Profile service returns:

{
  riskRating: LOW,
  country: US
}


Final response:

{
  dealId: D1001,
  status: SUCCESS,
  data: {
     riskRating: LOW,
     country: US
  }
}

Example 2 ‚Äì ADR

Input:

dealId: D2001
enrichmentType: ADR
payload:
   cusip: 123456
   exchange: NYSE


Router selects AdrProcessor.

Response:

{
  adrRatio: 2:1,
  depositaryBank: JPM
}

What Happens Without Generics

All processors return Map

Casting everywhere

Runtime ClassCastException risk

Not type safe

No compile-time guarantee

Example failure:
ADR returning Map but code expects ProfileResponse ‚Üí runtime failure.

What Happens With Generics

Compile-time safety

Each processor strictly typed

No casting in business code

Easy unit testing

Extendable

Framework-level design

Works clean in microservices
